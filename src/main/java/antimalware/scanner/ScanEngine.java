package antimalware.scanner;

import antimalware.database.IDatabase;
import antimalware.database.data.Signature;
import antimalware.database.data.Suspect;
import antimalware.scanner.data.report.ScanReport;
import antimalware.scanner.data.scan.ScanObject;
import antimalware.scanner.data.scan.ScanRegion;
import com.sun.xml.internal.messaging.saaj.util.ByteInputStream;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public class ScanEngine {

    private ScanObject scanObject;
    private IDatabase database;
    private ScanReport scanReport;
    private byte[] previousBlock;

    public ScanEngine(ScanObject scanObject, IDatabase database, ScanReport scanReport) {
        this.scanObject = scanObject;
        this.database = database;
        this.scanReport = scanReport;
    }

    public ScanReport start() {
        if (scanObject != null) {
            scanObj(scanObject);
            return scanReport;
        }
        return null;
    }

    private List<Suspect> scanRegion(ScanRegion scanRegion) {
        List<Suspect> suspectList = new ArrayList<>();
        //Date startTime = new Date();
        byte[] nextBlock = scanRegion.read();
        while (nextBlock != null && nextBlock.length > 0) {
            //System.out.println("Сканиуруем следующий блок...");
            int prefixSize = Signature.getPrefixSize();
            ByteBuffer byteBuffer;
            if (previousBlock == null) {
                byteBuffer = ByteBuffer.allocate(nextBlock.length);
            } else {
                byteBuffer = ByteBuffer.allocate(nextBlock.length + previousBlock.length);
                byteBuffer.put(previousBlock);
            }
            byteBuffer.put(nextBlock);
            ByteInputStream bis = new ByteInputStream();
            bis.setBuf(byteBuffer.array());
            for (int i = 0; (i + prefixSize) < byteBuffer.limit(); i++) {
                byte[] signBytes = new byte[prefixSize];
                bis.skip(i);
                try {
                    bis.read(signBytes);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                bis.reset();
                List<Suspect> suspects = database.search(ByteBuffer.wrap(signBytes));
                if (suspects != null) {
                    boolean skip = false;
                    for (Suspect suspect : suspects) {
                        Signature signature = suspect.getSignature();
                        int length = signature.getLength();
                        if (length <= byteBuffer.limit() - i) {
                            try {
                                //TODO: Сделать статичный метод получения хэша в классе Signature
                                byte[] h = MessageDigest.getInstance("SHA-256").digest(getSubArray(bis.getBytes(), i, length));
                                String hash = new String(h);
                                if (hash.equals(new String(signature.getHash()))) {
                                    suspectList.add(suspect);
                                    /*List<Suspect> scanReportSuspects = scanReport.getSuspects();
                                    scanReportSuspects.add(suspect);
                                    scanReport.setSuspects(scanReportSuspects);*/
                                }
                            } catch (NoSuchAlgorithmException e) {
                                e.printStackTrace();
                            }
                        } else {
                            previousBlock = nextBlock;
                            nextBlock = scanRegion.read();
                            break;
                        }
                    }
                    if (skip) continue;
                }
            }
            previousBlock = getSubArray(nextBlock, nextBlock.length - prefixSize, prefixSize);
            nextBlock = scanRegion.read();
            try {
                bis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        //Date stopTime = new Date();
        //float time = (stopTime.getTime() - startTime.getTime())/1000f;
        //System.out.println("Затрачено " + time + " секунд");
        return suspectList;
    }

    private void scanObj(ScanObject scanObject) {
        if (scanObject != null) {
            List<ScanRegion> scanRegions = scanObject.getScanRegions();
            if (scanRegions != null && scanRegions.size() > 0) {
                for (ScanRegion nextScanRegion : scanRegions) {
                    List<Suspect> suspects = scanRegion(nextScanRegion);
                    if (suspects != null && suspects.size() > 0) {
                        scanReport.addSuspects(scanObject, suspects);
                    }
                }
            }
            List<ScanObject> scanObjects = scanObject.getScanObjects();
            if (scanObjects != null && scanObjects.size() > 0) {
                for (ScanObject nextScanObject : scanObjects) {
                    scanObj(nextScanObject);
                }
            }
        }
    }

    private byte[] getSubArray(byte[] array, int off, int len) {
        byte[] subArray = new byte[len];
        int stop = off + len;
        for (int i = off, j = 0; i < stop; i++, j++) {
            subArray[j] = array[i];
        }
        return subArray;
    }
}
